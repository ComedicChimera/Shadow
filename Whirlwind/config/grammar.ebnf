// WHIRLWIND STANDARD GRAMMAR
whirlwind: ( global_variable_decl ';'
| enum_const ';'
| block_decl
| include_stmt ';'
| export_decl
| trait_decl
| trait_impl
)+ ;

main: ( func_decl
| block_stmt 
| stmt
| subscope
)+ ;

global_variable_decl: ['VOLATILE'] variable_decl ;
subscope: '{' main '}' ;

// include statement
include_stmt: ['USE'] 'INCLUDE' pkg_name [ with_clause ] ['STRING_LITERAL'] ;
pkg_name: [pkg_back_move] 'IDENTIFIER' ('.' 'IDENTIFIER' | pkg_back_move )* ;
pkg_back_move: '.' '.' ;
with_clause: 'WITH' '{' 'IDENTIFIER' (',' 'IDENTIFIER') '}' ;


// TRAITS
// trait declaration
trait_decl: 'TRAIT' 'IDENTIFIER' [ '(' trait_arg_list ')' ] trait_block ;
trait_arg_list: trait_arg (',' trait_arg )*;
trait_arg: 'IDENTIFIER' extension ;

trait_block: '{' main '}' ;

// trait implementation
trait_impl: '#' '[' trait_impl_arg (',' trait_impl_arg)* ']' trait_impl_block;
trait_impl_block: global_variable_decl
| func_decl 
| obj_decl
| struct_decl
;
trait_impl_arg: 'IDENTIFIER' ['(' args_list ')'] ;


// OBJECTS AND OBJECT COMPONENTS
// object declaration
obj_decl: 'TYPE' ['PARTIAL'] 'IDENTIFIER' partial* '{' obj_main+ '}' ;
obj_main: modifiers* ( variable_decl ';' 
| enum_const ';'
| method_decl
| method_template
| variant_decl
| constructor_decl
| obj_trait_impl
) ;

// method declaration
method_decl: ('FUNC' | 'ASYNC') ['PARTIAL'] 'IDENTIFIER' '(' args_decl_list ')' [ types ] partial* (func_body | ';') ;

// method template
method_template: 'TEMPLATE' '<' template (',' template)* '>' method_decl ;

// constructor declaration
constructor_decl: 'CONSTRUCTOR' '(' args_decl_list ')' func_body ;

// trait implementations for methods
obj_trait_impl: '#' '[' trait_impl_arg (',' trait_impl_arg)* ']' method_decl ;

// common object patterns
partial: ':' 'IDENTIFIER' ; // partial extension
modifiers: 'PRIVATE' | 'STATIC' | 'PROTECTED'; // variable and function modifiers


// BLOCK DECLARATIONS
block_decl: func_decl
| interface_decl
| obj_decl
| struct_decl
| template_decl
| variant_decl
;

// function declaration
func_decl: ('FUNC' | 'ASYNC') 'IDENTIFIER' '(' args_decl_list ')' [ types ] func_body ;

// interface declaration
interface_decl: 'INTERFACE' 'IDENTIFIER' '{' interface_main '}' ;
interface_main: interface_func+ ;
interface_func: ('FUNC' | 'ASYNC') 'IDENTIFIER' '(' args_decl_list ')' [ types ] ( ';' | func_body ) ;

// struct declaration
struct_decl: 'STRUCT' 'IDENTIFIER' '{' struct_main '}' ;
struct_main: (struct_var ';')+ ;
struct_var: 'IDENTIFIER' (',' 'IDENTIFIER')* ':' types ;

// template declaration
template_decl: 'TEMPLATE' '<' template (',' template)* '>' block_decl ;
template: 'IDENTIFIER' [':' type_list] ;

// variant declaration
variant_decl: 'VARIANT' ( variant | variant_list ) 'IDENTIFIER' func_body ;
variant_list: '(' variant (',' variant)+ ')' ;
variant: '<' type_list '>' ;


// BLOCK STATEMENTS (control flow, context managers and except blocks)
block_stmt: if_stmt
| select_stmt
| for_loop
| do_loop
| except_block
| with_block
| export_decl
;

// if statement
if_stmt: 'IF' '(' expr ')' block elif_block* [else_block] ;
elif_block: 'ELIF' '(' expr ')' block ;
else_block: 'ELSE' block ;

// select statement
select_stmt: 'SELECT' '(' expr ')' '{' select_block '}' ;
select_block: case+ [default] ;
case: 'CASE' expr (',' expr)* ':' main ;
default: 'DEFAULT' ':' main ;

// for loop
for_loop: 'FOR' [for_body] block ;
for_body: '(' (c_for | expr) ')'
| expr iterator '=>'
;

c_for: ['$' 'IDENTIFIER' '=' expr] ';' [expr] ';' [expr | assignment] ;

// do loop
do_loop: 'DO' (block do_for | '(' expr ')' block ) ;
do_for: 'FOR' '(' expr ')' ';' ;

// except block
except_block: 'EXCEPT' '(' handle_block+ ')' (block | ';') ;
handle_block: expr ':' '(' 'IDENTIFIER' ')' '=>' block ;

// context manager
with_block: 'WITH' '(' variable_decl ')' block ;

// export declaration
export_decl: 'EXPORT' ( block_decl
| include_stmt ';'
| variable_decl ';'
| enum_const ';'
);


// STATEMENTS
// broken up for logical reasons - takes advantage of multiple solution parsing
stmt: ( local_variable_decl
| enum_const
| assignment
| expr
| throw_stmt 
| continue_stmt
| break_stmt
| delete_stmt
| return_stmt
| yield_stmt
) ';' 
;

// local variable declaration
local_variable_decl: ('STATIC' | 'VOLATILE')* variable_decl;

// variable declaration
variable_decl: ('$' | '@') var extension variable_initializer  ;
var: '(' 'IDENTIFIER' extension variable_initializer (',' 'IDENTIFIER' extension variable_initializer)* ')'
| 'IDENTIFIER'
;

variable_initializer: [ '=' expr
| ':=' expr
] ;

// enumerated constant
enum_const: '@' '{' first_const 'IDENTIFIER'+ '}' ;
first_const: 'IDENTIFIER' variable_initializer ;

// variable assignment
assignment: assign_var (',' assign_var)* assign_op expr (',' expr)* ;
assign_var: ( 'IDENTIFIER' | 'THIS' ) trailer* ;

assign_op: [ '+'
| '-'
| '*'
| '/'
| '%'
| '^'
| '<<'
| '>>'
| 'AND'
| 'OR'
| 'XOR'
] 
'=' ;

// simple statements
continue_stmt: 'CONTINUE' ;
break_stmt: 'BREAK' ;
throw_stmt: 'THROW' expr ;
delete_stmt: 'DELETE' 'IDENTIFIER' (',' 'IDENTIFIER')* ;
return_stmt: 'RETURN' [expr (',' expr)*] ;
yield_stmt: 'YIELD' [expr (',' expr)*] ;


// EXPRESSIONS - basic unit of statements 
expr: or [expr_extension] | select_expr ;
expr_extension: '?' or ':' or
| ('??' or)+
;

// select expression
select_expr: 'SELECT' '{' select_condition+ select_closer '}' ;
select_condition: '?' expr '=>' expr ';' ;
select_closer: ':' expr ';' ;

// logical operators
or: xor ('OR' xor)* ;
xor: and ('XOR' and)* ;
and: comparison ('AND' comparison)* ;

// comparisons
comparison: not (comparison_op not)*;
comparison_op: '>' | '<' | '>=' | '<=' | '==' | '!=' ;
not: ['!'] shift ;

// binary shifts
shift: arithmetic (shift_op arithmetic)* ;
shift_op: '>' '>' | '<' '<';

// arithmetic
arithmetic: term (('+' | '-') term)* ;
term: factor (('*' | '/' | '%' | '~/') factor)* ;
factor: unary_atom ('^' unary_atom)*;

// unary operators
unary_atom: ('&' | '-' | '~' | '++' | '--' | '*'+) atom
| atom ['++' | '--']
;


// ATOMS - basic unit of expressions
atom: [ 'NEW' ] [ 'AWAIT' ] base trailer*
| comprehension trailer*
| heap_alloc
;

trailer: '[' (expr [slice] | slice) ']'
| '(' args_list ')'
| '{' init_list '}'
| '.' 'IDENTIFIER'
| '|>' aggr_expr '|'
| '->' 'IDENTIFIER'
| template_spec
;

// trailer components
slice: ':' [expr [':' expr] | ':' expr] ;
args_list: [arg (',' arg)*] ;
arg: 'IDENTIFIER' initializer 
| expr ;
init_list: 'IDENTIFIER' initializer (',' 'IDENTIFIER' initializer)* ;

// aggregator
aggr_expr: expr
| '...' aggr_op
;
aggr_op: '+' | '-' | '*' | '/' | '^' | '%' 
| '&&' | '||' | '^^' 
| '>>' | '<<' | '>>>'
| comparison_op
;

// for comprehension
comprehension: 'FOR' '(' expr iterator '=>' expr [':' expr] ['IF' expr] ')' ;

// allocate a type on the heap
heap_alloc: 'NEW' '(' alloc_body ')' ;
alloc_body: types [',' expr] ;


// BASES - lowest component of an atom
base: 'INTEGER_LITERAL'
| 'FLOAT_LITERAL'
| 'BOOL_LITERAL'
| 'STRING_LITERAL'
| 'CHAR_LITERAL'
| 'HEX_LITERAL'
| 'BINARY_LITERAL'
| 'NULL'
| 'THIS'
| 'IDENTIFIER'
| array
| list
| map
| tuple
| closure
| sub_expr
| type_cast
| sizeof
;

// collection types
array: '{' expr ( ',' expr )* '}' ;
list: '[' expr ( ',' expr )* ']' ;
map: '{' expr ':' expr (',' expr ':' expr)* '}' ;

// tuple literal
tuple: '(' expr (',' expr)+ ')' ;

// both inline functions (closures)
closure: 'FUNC' '(' args_decl_list ')' func_body
| 'ASYNC' '(' args_decl_list ')' func_body
;

// sub expr declared so that it could be easier to parse
sub_expr: '(' expr ')' ;

// casting syntax includes call
type_cast: 'CAST' '<' types '>' '(' expr ')' ;

// size of operator call
sizeof: 'SIZEOF' '(' ( types | expr ) ')' ;


// DATA TYPES - data type literals
types: '*'* ( base_types
| 'IDENTIFIER' [template_spec]
)
;

base_types: ['UNSIGNED'] simple_types
| collection_types
| func_types
| tuple_type
;

simple_types: 'BOOL_TYPE'
| 'FLOAT_TYPE'
| 'INT_TYPE'
| 'STRING_TYPE'
| 'CHAR_TYPE'
| 'BYTE_TYPE'
| 'LONG_TYPE'
| 'DOUBLE_TYPE'
| 'VOID_TYPE'
;

collection_types: 'ARRAY_TYPE' '[' types ',' expr ']'
| 'LIST_TYPE' '[' types ']'
| 'MAP_TYPE' '[' types ',' types ']'
;

func_types: 'FUNC' '(' args_decl_list ')' '(' type_list ')'
| 'ASYNC' '(' args_decl_list ')' '(' type_list ')'
;

tuple_type: '(' type_list ')' ;


// COMMON CONSTRUCTIONS - common structures used repeatedly in grammar
type_list: types (',' types)* ;

args_decl_list: [ decl_arg (',' decl_arg)* [',' ending_arg] | ending_arg ] ;
decl_arg: 'IDENTIFIER' (',' 'IDENTIFIER')* arg_ext [initializer] ;
arg_ext: ':' ['@'] types ;
ending_arg: '...' 'IDENTIFIER' [ arg_ext ] ;

initializer: '=' expr ;
iterator: '|' 'IDENTIFIER' (',' 'IDENTIFIER')* '|' ;
template_spec: '<' type_list '>' ;

// type extension
extension: [':' types] ;

// function body
func_body: [func_guard] ('{' [main] '}'
| '=>' expr (',' expr)* ';'
)
;

// function guard
func_guard: 'WHERE' '(' expr ')' ;

// standard block
block: '{' [main] '}'
| stmt
;
