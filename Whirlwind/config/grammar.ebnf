// WHIRLWIND STANDARD GRAMMAR
whirlwind: ( variable_decl ';'
| block_decl
| include_stmt ';'
| export_decl
| annotation
)+ ;

main: ( func_decl
| block_stmt 
| stmt
| subscope
)+ ;

subscope: '{' main '}' ;

// compiler annotation
annotation: '#' 'IDENTIFIER' ['STRING_LITERAL'] ;

// include statement
include_stmt: 'INCLUDE' ( pkg_name ['AS' 'IDENTIFIER'] | include_set 'FROM' pkg_name ) ;
pkg_name: [pkg_back_move] 'IDENTIFIER' (':' ':' 'IDENTIFIER' | pkg_back_move 'IDENTIFIER')* ;
pkg_back_move: '.' '.' ;
include_set: '{' ( 'IDENTIFIER' (',' 'IDENTIFIER')* | '...' ) '}' ;

// export declaration
export_decl: 'EXPORT' ( block_decl
| include_stmt ';'
| variable_decl ';'
) ;

// BLOCK DECLARATIONS
block_decl: func_decl
| interface_decl
| type_class_decl
| struct_decl
| variant_decl
| decor_decl
| interface_bind
;

// function declaration
func_decl: ('FUNC' | 'ASYNC') 'IDENTIFIER' [generic_tag] '(' args_decl_list ')' [ types ] (func_body | ';') ;

// interface declaration
interface_decl: 'INTERF' 'IDENTIFIER' [generic_tag] '{' interface_main '}' ;
interface_main: ( func_decl | variant_decl | operator_decl )+ ;

// interface binding declaration
interface_bind: 'INTERF' [generic_tag] 'FOR' types ['IS' implements] '{' interface_main '}' ;
implements: types (',' types)* ;

// operator overload
operator_decl: 'OPERATOR' '(' ( operator | ext_op ) ')' [generic_tag] '(' args_decl_list ')' [types] (func_body | ';') ;
ext_op: '[' [ ':' ] ']' | ':>' | '.' '.' ;

// type class declaration
type_class_decl: 'TYPE' 'IDENTIFIER' [generic_tag] [ type_class_main | ( '|' type_class_main )+ ] ';' ;
type_class_main: ( 'IDENTIFIER' type_constructor | type_id ) [value_restrictor] ;
type_constructor: '(' type_id ( ',' type_id )* ')' ;
value_restrictor: 'WHEN' expr ;

// struct declaration
struct_decl: 'STRUCT' 'IDENTIFIER' [generic_tag] '{' struct_main '}' ;
struct_main: (struct_var ';' | constructor_decl )+ ;
struct_var: ['OWN'] ['VOL'] 'IDENTIFIER' (',' 'IDENTIFIER')* ':' types [initializer];

// constructor declaration
constructor_decl: 'CONSTRUCTOR' '(' args_decl_list ')' func_body ;

// variant declaration
variant_decl: 'VARIANT' ( variant | variant_list ) 'IDENTIFIER' func_body ;
variant_list: '(' variant (',' variant)+ ')' ;
variant: '<' type_list '>' ;

// decorator declaration
decor_decl: decor func_decl ;
decor: '@' ( '[' decor_expr (',' decor_expr)* ']' | decor_expr ) ;
decor_expr: 'IDENTIFIER' static_get* [ generic_spec ] [ '(' args_list ')' ];

// BLOCK STATEMENTS (control flow)
block_stmt: if_stmt
| select_stmt
| for_loop
;

// if statement
if_stmt: 'IF' '(' [ variable_decl ';' ] expr ')' block elif_block* [else_block] ;
elif_block: 'ELIF' '(' [ variable_decl ';' ] expr ')' block ;
else_block: 'ELSE' block ;

// select statement
select_stmt: 'SELECT' '(' expr ')' '{' select_block '}' ;
select_block: case+ [default] ;
case: 'CASE' case_expr (',' case_expr)* ':' main ;
default: 'DEFAULT' ':' main ;

// for loop
for_loop: 'FOR' [for_body] block [after_clause] ;
for_body: '(' (c_for | iterator | for_expr) ')' ;
c_for: ['IDENTIFIER' '=' expr] ';' [expr] ';' [expr | assignment] ;
for_expr: [ variable_decl ';' ] expr ;

// after clause
after_clause: 'AFTER' block ;


// STATEMENTS
// broken up for logical reasons - takes advantage of multiple solution parsing
stmt: ( variable_decl
| assignment
| expr
| continue_stmt
| break_stmt
| delete_stmt
| return_stmt
| yield_stmt
) ';' 
;

// variable declaration
variable_decl: ('LET' | 'CONST') ['STATIC'] ['VOL'] var extension variable_initializer  ;
var: '(' var_id (',' var_id)* ')'
| 'IDENTIFIER'
;
var_id: 'IDENTIFIER' extension variable_initializer
| '_'
;

variable_initializer: [ '=' expr
| ':=' expr
] ;

// variable assignment
assignment: assign_var (',' assign_var)* assign_op expr (',' expr)* ;
assign_var: '_' | expr ;

assign_op: [ operator ] '=' ;

// delete statement
delete_stmt: 'DELETE' delete_id (',' delete_id)* ;
delete_id: ['THIS' '.'] 'IDENTIFIER' trailer*;

// simple statements
continue_stmt: 'CONTINUE' ;
break_stmt: 'BREAK' ;
return_stmt: 'RETURN' [expr (',' expr)*] ;
yield_stmt: 'YIELD' expr (',' expr)* ;


// EXPRESSIONS - basic unit of statements 
expr: expr_var | func_op [expr_extension] ;
expr_extension: 'IF' expr 'ELSE' expr 
| select_extension+
| 'IS' type_id [then_extension]
| ':>' expr
| then_extension
| '.' '.' expr
| 'AS' types
; 

// expression local variable declaration
expr_var: 'IDENTIFIER' '=' func_op then_extension ;

// then extension
then_extension: 'THEN' expr ;

// select extension
select_extension: 'SELECT' '{' inline_case (',' inline_case)* [default_case] '}' ;
inline_case: case_expr (',' case_expr)* '=>' expr ;
default_case: ',' '_' '=>' expr ;

// functional/monadic operators
func_op: or (('>>=' | '~*') or)* ;

// logical operators
or: xor ('OR' xor)* ;
xor: and ('XOR' and)* ;
and: comparison ('AND' comparison)* ;

// comparisons
comparison: not (comparison_op not)*;
comparison_op: '>' | '<' | '>=' | '<=' | '==' | '!=' ;
not: ['!'] shift ;

// binary shifts
shift: arithmetic (shift_op arithmetic)* ;
shift_op: '>' '>' | '<' '<';

// arithmetic
arithmetic: term (('+' | '-') term)* ;
term: factor (('*' | '/' | '%' | '~/') factor)* ;
factor: unary_atom ('~^' unary_atom)*;

// unary operators
unary_atom: ('&' | '-' | '~' | '++' | '--' | '*' ['?'] ) atom
| atom ['++' | '--']
;


// ATOMS - basic unit of expressions
atom: [ 'NEW' ] [ 'AWAIT' ] base trailer*
| heap_alloc
| from_expr
;

trailer: '[' (expr [slice] | slice) ']'
| '(' args_list ')'
| '{' init_list '}'
| '.' ( 'IDENTIFIER' | 'INTEGER_LITERAL' )
| '->' 'IDENTIFIER'
| '?' '->' 'IDENTIFIER'
| generic_spec
| static_get
;

// trailer components
slice: ':' [expr [':' expr] | ':' expr] ;

args_list: [arg (',' arg)*] ;
arg: named_arg | expr ;
named_arg: 'IDENTIFIER' '=' expr ;

init_list: 'IDENTIFIER' initializer (',' 'IDENTIFIER' initializer)* ;

// comprehension
comprehension: '{' comp_body '}' | '[' comp_body ']' ;
comp_body: expr [':' expr] '|' iterator ['WHEN' expr] ;

// allocate a type on the heap
heap_alloc: 'MAKE' alloc_body ;
alloc_body: '(' types ',' expr ')'
| base trailer
| types
;

// access the value of a type class
from_expr: 'FROM' expr ;

// BASES - lowest component of an atom
base: 'INTEGER_LITERAL'
| 'FLOAT_LITERAL'
| 'BOOL_LITERAL'
| 'STRING_LITERAL'
| 'CHAR_LITERAL'
| 'HEX_LITERAL'
| 'BINARY_LITERAL'
| 'THIS'
| 'IDENTIFIER'
| 'NULL'
| 'VALUE'
| array
| list
| dict
| comprehension
| tuple
| lambda
| sub_expr
| partial_func
| super_call
;

// collection types
array: '{' expr ( ',' expr )* '}' ;
list: '[' expr ( ',' expr )* ']' ;
dict: '{' expr ':' expr (',' expr ':' expr)* '}' ;

// tuple literal
tuple: '(' expr (',' expr)+ ')' ;

// inline functions (lambdas)
lambda: ['ASYNC'] '|' args_decl_list '|' lambda_body ;
lambda_body: '=>' expr
| '{' [main] '}'
;

// sub expr declared so that it could be easier to parse
sub_expr: '(' expr ')' ;

// convert function to partial function
partial_func: '|' expr partial_arg (',' partial_arg)* ')' ;
partial_arg: '_'
| expr
;

super_call: 'SUPER' '(' [ 'IDENTIFIER' static_get* [ generic_spec ] ] ')' ;

// DATA TYPES - data type literals
types: ['CONST'] ( base_types
| 'IDENTIFIER' static_get* [generic_spec]
)
;

base_types: simple_types
| collection_types
| func_type
| tuple_type
| pointer_type
;

simple_types: 'BOOL_TYPE'
| 'FLOAT_TYPE'
| 'INT_TYPE'
| 'STRING_TYPE'
| 'CHAR_TYPE'
| 'BYTE_TYPE'
| 'LONG_TYPE'
| 'DOUBLE_TYPE'
| 'SHORT_TYPE'
| 'ANY_TYPE'
;

collection_types: '[' [ expr ] ']' types
| '[' types ']'
| '[' types ':' types ']'
;

func_type: ('FUNC' | 'ASYNC') '(' func_arg_types ')' '(' [ type_list ] ')' ;
func_arg_types: [ func_arg_type (',' func_arg_type)* ] [func_arg_indef] ;
func_arg_type: ['OWN'] types ['~'] ;
func_arg_indef: '...' [types] ;

tuple_type: '(' tuple_type_list ')' ;
tuple_type_list: types (',' types)+ ;

pointer_type: ['DYN'] '*' types ;


// COMMON CONSTRUCTIONS - common structures used repeatedly in grammar
// a series of types delimited by commas
type_list: types (',' types)* ;

// argument declaration syntax
args_decl_list: [ decl_arg (',' decl_arg)* [',' ending_arg] | ending_arg ] ;
decl_arg: ['OWN'] ['VOL'] 'IDENTIFIER' (',' 'IDENTIFIER')* extension [initializer] ;
ending_arg: '...' 'IDENTIFIER' extension ;

// general purpose initializer
initializer: '=' expr ;

// iterator syntax
iterator: iter_var (',' iter_var)* '<-' expr ;
iter_var: 'IDENTIFIER' | '_' ;

// type extension
extension: [':' types] ;

// function body
func_body: ('{' [main] '}'
| '=>' expr (',' expr)* ';'
)
;

// standard block
block: '{' [main] '}'
| stmt
;

// operator (wherever any operator can be used)
operator: '+' | '-' | '*' | '/' | '%' | '<' | '>' | '<=' | '>=' | '==' | '!='
| '>>=' | '~^' | '~*' | '~/' | '<' '<' | '>' '>' | 'AND' | 'OR' | 'XOR' | '~' ;

// generic tag (placed after several block declarations)
generic_tag: '<' generic (',' generic)* '>' ;
generic: 'IDENTIFIER' [':' type_list] ;

// generic specifier
generic_spec: '<' type_list '>' ;

// static get call
static_get: get_op 'IDENTIFIER' ;
get_op: ':' ':' ;

// type identifier pair
type_id: [ 'IDENTIFIER' ':' ] types ;

// case-expressions and patterns
case_expr: pattern | expr ;
pattern: ['IDENTIFIER' static_get*] '(' pattern_elem (',' pattern_elem)* ')' ;
pattern_elem: expr | '_' ;