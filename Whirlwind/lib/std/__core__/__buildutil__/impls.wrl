// TYPES

#impl "array"
struct __array<T> {
	p: *T;
	size: uint;
}

#impl "list"
struct __list<T> {
	p: dyn* T;
	size: uint;
	cap: uint;
}

#impl "dict"
struct __dict<K, V> {
	kvList: dyn* (K, V);
	kvSize, kvCap: uint;

	hashTable: dyn *int;
	htSize, htCap: uint;

	nextInsertNdx: uint;
}

#impl "string"
struct __string {
	bytes: *byte;
	byteCount: uint;

	length: uint;
}

#impl "any"
struct __any {
	val: *byte;
	cVar: short;
	size: int;
}

// CORE INTERFACES
interf Hashable {
	func hash() long;
}

// FRIEND FUNCTIONS
#friend "string"
func __concat(a, b: str) str {
	let np: *byte;
	__memcpy(np, a.bytes, a.byteCount);

	__memcpy(np + a.byteCount, b.bytes, b.byteCount);

	return new __string { bytes = np, byteCount = a.byteCount + b.byteCount, length = a.length + b.length } as str;
}

#friend "array"
func __concatA<T>(a, b: []T) {

}

#friend "list"
func __concatL<T>(a, b: [T]) {

}

// HELPER FUNCTIONS
/*func __range(l, h, step: int) []int {
	let size = h - l if step == 1 else l - h;
	let arr = __malloca(4 * size) as []int;		

	let n = l;
	for (i = 0; i < size; i++) {
		arr[i] = n;
		n += step;
	}

	return arr;
}*/

func __memcpy(dest: *byte, src: *byte, size: uint) {	
	for (i = 0u; i < size; i++) {
		*(dest + i) = *(src + i);
	}
}

// INTRINSIC FUNCTIONS
#intrinsic
func __malloca(size: uint) *byte;

#intrinsic
func __sizeof(data: any) uint;