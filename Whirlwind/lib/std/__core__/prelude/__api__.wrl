export include { Iterator, Iterable } from iter;


// ERRORS
// Error Interface
// represents the base interface for all other error types
export interf Error {
    func message() str;

    func trace() str {
        // add intrinsic here
    }
}


// INTERFACES
// Comparable Interface
// any value that defines overloads for ALL primary
// comparison operators (assumedly in a logical fashion)
export interf Comparable {
    template<T> 
    func __eq__(other: T) bool;

    template<T> 
    func __neq__(other: T) bool;

    template<T> 
    func __lt__(other: T) bool;

    template<T> 
    func __lteq__(other: T) bool

    template<T> 
    func __gt__(other: T) bool;

    template<T> 
    func __gteq__(other: T) bool;
}

// Hashable Interface
// any value that defines a hash method returning
// and unsigned integer designating its identity
export interf Hashable {
    func hash() uint;
}


// MATHEMATICAL BUILTINS
// rounds a double to the nearest integer
export func round(n: double) int
    => n % 1 > 0.5 ? floor(n) + 1 : floor(n);

// maps a double to the nearest, lesser integer 
export func floor(n: double) int
    => cast<int>(n - (n % 1));

// maps a double to the nearest, greater integer
export func ciel(n: double) int
    => floor(n) + 1;

// calculates the absolute of any numeric value (excluding char)
// type is assumed to be signed and returned signed
export template<T: int, double, float, long>
func abs(n: T) T
    => n > 0 ? n : -n;


// ITERABLE BUILTINS
/*
Creates a range of numbers from a inclusive to b exclusive
in addition, a step (s) can be provided such that
the range will generated moving in increments of n in either
direction.

If s < 0, then the range will be generated in reverse assuming
a is the larger value.  However, the range will still begin
at a and move until b.
*/ 
export func range(a: int, b: int = 0, s: int = 1) list[int] {
    let lst: list[int];

    if (s > 0 && b < a || s < 0 && b > a)
        a, b = b, a;

    // assumed end only case
    if (a > b && b == 0) {
        for (n = 0; n < a; n += s)
            lst.push(n);
    }
    elif (s > 0) {
        for (n = a; n < b; n += s)
            lst.push(n);
    }
    else {
        for (n = a; n > b; n += s)
            lst.push(n);
    }

    return lst;
}

/*
Joins to lists to form a dictionary where
each value is the first list is the key to
the value at the same index in the second list
in the resulting dictionary
*/
export template<K: Hashable, V>
func zip(keys: list[K], values: list[V]) dict[K, V] {
    let dct: dict[K, V];

    if (keys.len() == values.len()) {
        for (i = 0; i < keys.len(); i++)
            dct[keys[i]] = values[i];
    }
    else
        throw new ValueException("The number of keys must equal number of values");

    return dct;
}

// Finds the minimum value in any iterable of values which
// are comparable to a numeric by using standard comparison methods
export template<T: Comparable>
func min(it: Iterable<T>) T {
    let m = -Infinity;

    for (i <- it) {
        if (i < m)
            m = i;
    }

    return m;
}

// Finds the maximum value in any iterable of values which
// are comparable by using standard comparison methods
export template<T: Comparable>
func max(it: Iterable<T>) T {
    let m = -Infinity;

    for (i <- it) {
        if (i > m)
            m = i;
    }

    return m;
}

// Finds the sum of any iterable whose elements define an
// addition operator. The sum is calculated left to right.
export template<T>
func sum(it: Iterable<T>) T
    => it.reduce(|a, b: T| => a + b);


// UTILITY
// Takes in two comparable values and determines the lesser of the two
export template<T: Comparable>
func lesser(a, b: T) T
    => a > b ? b : a;

// Takes in two comparable values and determines the greater of the two
export template<T: Comparable>
func greater(a, b: T) T
    => a < b ? a : b;

// Determines if a double is a whole number
export func whole(n: double) bool
    => n % 1 == 0;

// Determines if a number is even
export func even(n: int) bool
    => n % 2 == 0;

/*
Restricts a numeric value to exist between two values

- val is the inital value
- s1 and e1 are the bounds for the initial value
- s2 and e2 are the bounds for the final value

the clamping formula is as follows:

VL - S1
------- * (E2 - S2) + S2
E1 - S1
*/ 
export template<T, S>
func clamp(val, s1, e1: T, s2, e2: S) double
    => (val - s1) / (e1 - s1) * (e2 - s2) + s2;


// SORTS
// uses to tim sort to sort a list of comparables into an ordered list
export template<T: Comparable>
func sort(it: Iterable<T>) list[T] {
    let sorted = it.collect();
    let len = sorted.len();

    for (r = 0; r < len; r += 32) {
        for (i = r; i < (r + 32 > len ? len : 32); i++) {
            let (temp = sorted[i], j = i - 1);

            for (temp > sorted[j] && j >= 0) {
                sorted[j + 1] = sorted[j];

                j--;
            }

            sorted[j + 1] = temp;
        }
    }

    let n = 32;
    for (n < len) {
        for (left = 0; left < len; left += 2 * n) {
            let (mid = left + n - 1, right = lesser(left + n * 2, len));

            sorted[left:right] = merge(ref sorted, left, mid, right);
        }

        n *= 2;
    }
        
    return sorted;
}

// merges two adjacent blocks of sorted items
template<T>
func merge(const arr: ref list[T], left, mid, right: int) list[T] {
    let result: list[T];
    let (i = left; j = mid);

    for (i < mid && j < right) {
        if (arr[i] <= arr[j]) {
            result.push(arr[i]);
            i++;
        }
        else {
            result.push(arr[j]);
            j++;
        }
    }

    for (; i < mid; i++) 
        result.push(arr[i]);

    for (; j < right; j++)
        result.push(arr[j]);

    return result;
}


// uses LSD Radix Sort (base 10) to sort based values based on a key function that returns an unsigned integer
// into a list of values
export template<T> 
func keySort(it: Iterable<T>, key=|x: T| => cast<Hashable>(x).hash()) list[T] {
    let keyDct: dict[uint, list[T]];

    for (n <- it) {
        let k = key(n);

        keyDct[k] = keyDct.get(k) + [n];
    }

    let sorted = keyDct.keys();

    let (len= sorted.len(), mx = max(sorted));
    for (pow = 0; 10 ~^ pow < mx; pow++) {
        let buckets: list[list[uint]] = for(null | _ <- range(10));

        for (n <- sorted) {
            buckets[n ~/ (10 ~^ pow) % 10] = n;
        }

        sorted = buckets.foldl(|a, b: list[uint]| => a + b);
    }
        
    return for(keyDct[x] | x <- sorted).foldl(|a, b: list[T]| => a + b);
}