// Iterable Interface
// any value that iterated upon using a standard iterator
// these values are usable in for loops, comprehensions, ect.
export template<T>
interf Iterable {
    // the starting index, length, and all iterable indices must
    // be unsigned

    // returns the value of the iterable at any given index
    priv func at(ndx: uint) T;

    // returns the starting index for the iterable
    // this value should be the lowest index in the iterable
    // as iterators progress in order of lowest to highest
    func begin() uint;

    // return the length of the iterable
    // or equivalently how many moves a standard iterator can take
    func len() uint;
}

// Comparable Interface
// any value that defines overloads for ALL primary
// comparison operators (assumedly in a logical fashion)
export interf Comparable {
    template<T> 
    func __eq__(other: T) bool;

    template<T> 
    func __neq__(other: T) bool;

    template<T> 
    func __lt__(other: T) bool;

    template<T> 
    func __lteq__(other: T) bool

    template<T> 
    func __gt__(other: T) bool;

    template<T> 
    func __gteq__(other: T) bool;
}

// Hashable Interface
// any value that defines a hash method returning
// and unsigned integer designating its identity
export interf Hashable {
    func hash() uint;
}

// MATHEMATICAL BUILTINS
// rounds a double to the nearest integer
export func round(n: double) int
    => n % 1 > 0.5 ? floor(n) + 1 : floor(n);

// maps a double to the nearest, lesser integer 
export func floor(n: double) int
    => cast<int>(n - (n % 1));

// maps a double to the nearest, greater integer
export func ciel(n: double) int
    => floor(n) + 1;

// calculates the absolute of any numeric value (excluding char)
// type is assumed to be signed and returned signed
export template<T: int, double, float, long>
func abs(n: T) T
    => n > 0 ? n : -n;


// ITERABLE BUILTINS
/*
Creates a range of numbers from a inclusive to b exclusive
in addition, a step (s) can be provided such that
the range will generated moving in increments of n in either
direction.

If s < 0, then the range will be generated in reverse assuming
a is the larger value.  However, the range will still begin
at a and move until b.
*/ 
export func range(a: int, b: int = 0, s: int = 1) list[int] {
    let lst: list[int];

    if (s > 0 && b < a || s < 0 && b > a)
        a, b = b, a;

    if (s > 0) {
        for (n = a; n < b; n += s)
            lst.push(n);
    }
    else {
        for (n = a; n > b; n += s)
            lst.push(n);
    }

    return lst;
}

/*
Joins to lists to form a dictionary where
each value is the first list is the key to
the value at the same index in the second list
in the resulting dictionary
*/
export template<K: Hashable, V>
func zip(keys: list[K], values: list[V]) dict[K, V] {
    let dct: dict[K, V];

    if (keys.len() == values.len()) {
        for (i = 0; i < keys.len(); i++)
            dct[keys[i]] = values[i];
    }
    else
        throw new ValueException("The number of keys must equal number of values");

    return dct;
}

// Finds the minimum value in any iterable of values which
// are comparable to a numeric by using standard comparison methods
export template<T: Comparable>
func min(it: Iterable<T>) T {
    let m = -Infinity;

    for (i <- it) {
        if (i < m)
            m = i;
    }

    return m;
}

// Finds the maximum value in any iterable of values which
// are comparable by using standard comparison methods
export template<T: Comparable>
func max(it: Iterable<T>) T {
    let m = -Infinity;

    for (i <- it) {
        if (i > m)
            m = i;
    }

    return m;
}

// Finds the sum of any iterable whose elements define an
// addition operator. The sum is calculated left to right.
export template<T>
func sum(it: Iterable<T>) T
    => it.reduce(|a, b: T| => a + b);


// UTILITY
// Takes in two comparable values and determines the lesser of the two
export template<T: Comparable>
func lesser(a, b: T) T
    => a > b ? b : a;

// Takes in two comparable values and determines the greater of the two
export template<T: Comparable>
func greater(a, b: T) T
    => a < b ? a : b;

// Determines if a double is a whole number
export func whole(n: double) bool
    => n % 1 == 0;

// Determines if a number is even
export func even(n: int) bool
    => n % 2 == 0;

/*
Restricts a numeric value to exist between two values

- val is the inital value
- s1 and e1 are the bounds for the initial value
- s2 and e2 are the bounds for the final value

the clamping formula is as follows:

VL - S1
------- * (E2 - S2) + S2
E1 - S1
*/ 
export template<T, S>
func clamp(val, s1, e1: T, s2, e2: S) double
    => (val - s1) / (e1 - s1) * (e2 - s2) + s2;


// SORTS
// uses Tim Sort to sort based values based on a key function that returns an unsigned integer
export template<T> 
func sort(it: Iterable<T>, key=|x: T| => cast<Hashable>(x).hash()) Iterable<T> {
    let keyDct: dict[uint, list[T]];

    for (n <- it) {
        let k = key(n);

        keyDct[k] = keyDct.get(k) + [n];
    }

    let sorted = keyDct.keys();
    let len = sorted.len();

    for (r = 0; r < len; r += 32) {
        for (i = r; i < (r + 32 > len ? len : 32); i++) {
            let (temp = sorted[i], j = i - 1);

            for (temp > sorted[j] && j >= 0) {
                sorted[j + 1] = sorted[j];

                j--;
            }

            sorted[j + 1] = temp;
        }
    }

    let n = 32;
    for (n < len) {
        for (left = 0; left < len; left += 2 * n) {
            let (mid = left + n - 1, right = lesser(left + n * 2, len));

            sorted[left:right] = merge(ref sorted, left, mid, right);
        }

        n *= 2;
    }
        
    return sorted.map(|x: uint| => keyDct[x]).foldl(|a, b: list[T]| => a + b);
}

// add numeric only sort

// merges two adjacent blocks of sorted items
template<T>
func merge(const arr: ref list[T], left, mid, right: int) list[T] {
    let result: list[T];
    let (i = left; j = mid);

    for (i < mid && j < right) {
        if (arr[i] <= arr[j]) {
            result.push(arr[i]);
            i++;
        }
        else {
            result.push(arr[j]);
            j++;
        }
    }

    for (; i < mid; i++) 
        result.push(arr[i]);

    for (; j < right; j++)
        result.push(arr[j]);

    return result;
}
