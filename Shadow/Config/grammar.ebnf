// temporary
main: ( block_stmt 
| stmt
)+ ;

// block statements (control flow, context managers and except blocks)
block_stmt: if_stmt
| select_stmt
| match_stmt
| for_loop
;

/*
| for_stmt
| do_stmt
| except_stmt
| with_stmt
; */

// if statement
if_stmt: 'IF' '(' expr ')' block elif_block* [else_block] ;
elif_block: 'ELIF' '(' expr ')' block ;
else_block: 'ELSE' block ;

// select statement
select_stmt: 'SELECT' '(' expr ')' '{' select_block '}' ;
select_block: case+ [default] ;
case: 'CASE' expr (',' expr)* ':' main ;
default: 'DEFAULT' ':' main ;

// match statement
match_stmt: 'MATCH' '{' match_case+ '}' ;
match_case: '?' expr ':' main ;

// for loop
for_loop: 'FOR' [for_body] block ;
for_body: '(' (c_for | expr) ')'
| expr iterator '=>'
;

c_for: ['$' 'IDENTIFIER' '=' expr] ';' [expr] ';' [expr | assignment] ;

// STATEMENTS
// broken up for logical reasons - takes advantage of multiple solution parsing
stmt: ( variable_decl
| include_stmt
| enum_const
| assignment
| expr
| throw_stmt 
| continue_stmt
| break_stmt
| delete_stmt
| return_stmt
) ';' 
;

// variable declaration
variable_decl: ['LOCK'] ['EXTERN'] ('$' | '@') var extension variable_initializer  ;
var: '(' 'IDENTIFIER' extension variable_initializer (',' 'IDENTIFIER' extension variable_initializer)* ')'
| 'IDENTIFIER'
;

variable_initializer: [ '=' expr
| ':=' expr
] ;

// include statement
include_stmt: ['EXTERN'] ['USE'] 'INCLUDE' pkg_name ['STRING_LITERAL'] ;
pkg_name: 'IDENTIFIER' ('.' 'IDENTIFIER')* ;

// enumerated constant
enum_const: '@' '{' 'IDENTIFIER'+ '}' ;

// variable assignment
assignment: assign_var (',' assign_var)* assign_op expr (',' expr)* ;
assign_var: 'IDENTIFIER' ( '.' 'IDENTIFIER'
| '[' (expr [slice] | slice) ']'
)* ;

assign_op: '='
| '+='
| '-='
| '*='
| '/='
| '%='
| '^='
;

// simple statements
continue_stmt: 'CONTINUE' ;
break_stmt: 'BREAK' ;
throw_stmt: 'THROW' expr ;
delete_stmt: 'DELETE' 'IDENTIFIER' (',' 'IDENTIFIER')* ;
return_stmt: ('YIELD' | 'RETURN') [expr (',' expr)*] ;

// EXPRESSIONS - basic unit of statements 
expr: or [expr_extension] ;
expr_extension: '?' or ':' or
| ('??' or)+
;

// logical operators
or: xor ('OR' xor)* ;
xor: and ('XOR' and)* ;
and: comparison ('AND' comparison)* ;

// comparisons
comparison: not (comparison_op not)*;
comparison_op: '>' | '<' | '>=' | '<=' | '==' | '!=' | '===' | '!===' ;
not: ['!'] shift ;

// binary shifts
shift: arithmetic (('>>' | '<<' | '>>>') arithmetic)* ;

// arithmetic
arithmetic: term (('+' | '-') term)* ;
term: factor (('*' | '/' | '%') factor)* ;
factor: unary_atom ('^' unary_atom)*;

// unary operators
unary_atom: ('&' | '-' | '++' | '--' | '*'+ ) atom
| atom ['++' | '--']
;

// ATOMS - basic unit of expressions
atom: [ 'NEW' ] [ 'AWAIT' ] base trailer*
| '(' expr ')'
| comprehension trailer*
;

trailer: '[' (expr [slice] | slice) ']'
| '(' args_list ')'
| '{' init_list '}'
| '.' 'IDENTIFIER'
| '|>' aggr_expr '|'
| '...'
;

// trailer components
slice: ':' [expr [':' expr]] ;
args_list: [['...'] expr [initializer] (',' ['...'] expr [initializer])*]  ;
init_list: ('IDENTIFIER' initializer)+ ;

// aggregator
aggr_expr: expr
| ... aggr_op
;
aggr_op: '+' | '-' | '*' | '/' | '^' | '%' 
| '&&' | '||' | '^^' 
| '>>' | '<<' | '>>>'
| comparison_op
;

// for comprehension
comprehension: 'FOR' '(' expr iterator '=>' expr ['IF' expr] ')' ;

// BASES - lowest component of an atom
base: 'INTEGER_LITERAL'
| 'FLOAT_LITERAL'
| 'BOOL_LITERAL'
| 'STRING_LITERAL'
| 'CHAR_LITERAL'
| 'HEX_LITERAL'
| 'BINARY_LITERAL'
| 'NULL'
| 'VALUE'
| 'THIS'
| 'IDENTIFIER'
| array
| list
| map
| atom_types
| inline_function
;

array: '{' [ expr ( ',' expr )* ] '}' ;
list: '[' [ expr ( ',' expr )* ] ']' ;
map: '{' [ expr ':' expr (',' expr ':' expr)* ] '}' ;

inline_function: 'FUNC' '(' args_decl_list ')' func_body
| 'ASYNC' '(' args_decl_list ')' func_body
;

// DATA TYPES - data type literals
types: atom_types
| 'IDENTIFIER'
;

atom_types: simple_types
| collection_types
| func_types
;

simple_types: 'BOOL_TYPE'
| 'FLOAT_TYPE'
| 'INT_TYPE'
| 'STRING_TYPE'
| 'CHAR_TYPE'
| 'DATA_TYPE'
| 'BYTE_TYPE'
| 'LONG_TYPE'
;

collection_types: 'ARRAY_TYPE' '[' types ',' expr ']'
| 'LIST_TYPE' '[' types ']'
| 'MAP_TYPE' '[' types ',' types ']'
;

func_types: 'FUNC' '(' args_decl_list ')' '(' type_list ')'
| 'ASYNC' '(' args_decl_list ')' '(' type_list ')'
;

// COMMON CONSTRUCTIONS - common structures used repeatedly in grammar
type_list: types (',' types)* ;
args_decl_list: (['...'] ('$' | '@' | '&') 'IDENTIFIER' extension [initializer])* ;
initializer: '=' expr ;
iterator: '|' 'IDENTIFIER' (',' 'IDENTIFIER')* '|' ;

// type extension
extension: [':' types] ;

// function body
func_body: '{' main '}'
| '=>' expr
| stmt 
;

// standard block
block: '{' main '}'
| stmt
;
