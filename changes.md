# Changes

- make errors include positions (TokenError, ASTError, etc.)
- remove `->` operator, just use `.` for everything (inc. methods), update `?->` to `?.` accordingly
- overload `?.` for interfaces
- split up loops into two categories: `for` and `loop`
  - `loop` is for infinite and conditional loops `loop (expr) { ... }`
    and `loop { }` for infinite loops
  - `for` is for iterative for loops (c-style, iterators)
- make init lists main way to initialize structured types
  - don't have to provide values for everything
- constancy only applies to references and variables (mutable, named values)
  - for variable declarators:
    - `const x ...`
    - constancy will be applied as an optimization after semantic checking
      where possible
  - same syntax for structs and function arguments
  - for references:
    - `&const x` (create a const reference to x)
    - `const dyn* x` (constant dynamic reference)
    - `const* x` (const stack reference)
    - `const vol* x` (constant volatile reference)
  - reference constancy is viral
    - `let x = &const y;` (x is now a const reference)
    - x can still be mutated, the reference cannot be
  - value constancy is not
    - `const x = 10; let y = x;` (y is not constant)
  - casting rules: mutable -> constant, constant -/> mutable
  - methods can be constant (explicitly)
  - cannot take a non-const reference to a constant value
- value categories
  - lvalue (well-defined, mutable value, able to take both kinds of references to it)
  - cvalue (well-defined, immutable value, only able to take a const reference to it, value constancy)
  - rvalue (undefined, immutable value, unable to take any kind of reference to it)
- partial function calling (replacement for old partial function syntax)
  - `f(_, 23, _)` creates a function from f that accepts the two arguments left blank
  - can allow for "currying" (not actually but...)
  - more clear than implicit currying/argument omission (re. Haskell)
- memory model
  - most memory management done in terms of references
  - a reference is like a pointer except you can't mutate the pointer directly
  - two kinds of references: regular and const references
  - `make` returns a reference
    - if it is a single item, it returns a reference to that item
    - if it is a block, returns a reference to an array
    - can be resized via `make &arr to new_size`
  - references can never be explicitly dereferenced and have virtually identical semantics
  to their non-reference counterparts
  - created with syntax `&value` or `&const value`
  - type label: `&type` or `const& type`
  - dereferences must be explicit; however,
    - many operators have reference forms (as well as nullable forms)
    - eg. `ref_struct.x`, `ref_array[2]`
  - compiler-determined lifetimes, user-defined ownership status
  - sometimes user will need to specify (ie. nonlocal lifetimes)
  - protective semantics
    - lifetime congruence (eg. can't return a stack reference, can't make a stack reference global)
    - `own` is a type specifier that determines what type of reference we are dealing with
    - ownership status must match exactly
    - notably, it maintains on rvalues across equals and drops for all other value categories
    - operator usage: `:>`, `delete`, and resize on mutable owned references, `=` on unowned references
  - remove nullable dereference (keep nullable get item)
  - make some trailers nullable
    - not allowed on generic specs, static gets, or init lists
  - no pointers (no pointer arithmetic, direct address manipulation)
  - lifetimes can be bound to data structures (selectively, via. `own` keyword)
  - double references are not allowed (and of course triple, quadruple, etc. are also disallowed)
    - can use combo of `own` or `const` to achieve equivalent behavior to C++
  - support for memory operator overloads
    - `delete` operator (implement finalizers - ran before deletion occurs)
  - references have a nullability status
    - designated like so `&?byte` -- syntax WIP
    - non-nullable references cannot be deleted (implicitly or explicitly)
    - nullable operators only valid on nullable references
    - type logic:
      - cannot be casted or coerced (given or taken away) on lvalue or cvalue references
      - rvalue references can become nullable but cannot become non-nullable
- move operator overloads outside of interfaces
  - allows for more efficient overloads (defined in terms of functions, makes more sense)
  - operators can be "left-handed" or "right-handed"
  - logically, an operator doesn't have a "primary operand" (when we see `2 + 3`, we don't think `2.add(3)`)
- builtin support for vectorization
  - vector constructor: `<value : const_len>` or `<{elems...}>`
  - vector data type: `<size>type` (only valid on integral, floating point or pointer types)
  - vector generics: `<T, in N>` (N is a size parameter to a vector data type)
  - all basic arithmetic operations are valid on vectors (scalar and vector mult)
  - additional intrinsics and utilities (eg. `__vec_sum(v)` and `__shuffle_vec(v1, v2, mask)`)
  - `#vec_unroll` annotation to cause vector functions to be optimized (as much as possible)
  - extended (later) as part of math library (intended for general purpose use, also used in matrices and complex numbers)
  - vector array initializers should be compiled as `shufflevector` if possible
  - VECTORS ARE ITERABLE
- intrinsic implementation
  - prevent intrinsics from being converted to first class functions
  - allow for generic intrinsics
  - `#intrinsic` annotation (implementation)
- inline method calls (as much as possible - may only be possible in type interfaces)
- remove group overloading (it just seems awkward - leads to duplication and ambiguity)
- add singleton "case" expression (outside of `is`)
  - eg. `tup case (3.14, s)`
  - useful extension of pattern matching
  - simplifies usage of `is` (no need for `x is Some(v)`, instead do `x case some(V)`)
- select statement extensions
  - `fallthrough` probably useful
  - `when cond` conditions on select case
  - only for statements (breaks completeness of expressions)
- heap alloc synactic "overhaul"
  - to allocate types: `make for type`
  - to allocate a block of types: `make for type * numtypes`
  - to allocate a value `make expr`
- make `ctx_strand()` intrinsic and access the current running strand from TLS
- restructure expressions
  - removed expression locals of all forms (confusing, not really helpful)
  - completely removed expression local bindings, allowed pattern matching to remain but not local
  - split up expression types (cond suffix now works on all expressions except other cond suffixes)
- remove `from ... as ...` syntax: just use pattern matching (safer)
- added context managers (and `with` keyword)
  - ensure that resources are cleaned up before they close (via. `close()` method)
  - even in case of runtime panic
  - same guarantee about `after` block
  - even circumvents breaks and returns (temporarily)
  - used when handling "hot" resources that must be properly disposed (at all costs, in all cases)
- remove "special" methods - no need for them (anymore)
- builtin collections implement as references to special type declarations
  - `[]T` -> `core::__array<T>`
  - `[T]` -> `core::__list<T>`
  - `[K: V]` -> `core::__dict<K, V>`
  - implement initializations as such
- allow for stacked annotations
- revised iterator syntax
  - use `in` instead of `<-` (easier to type and looks better)
  - use `for` instead of `|` in comprehensions (looks better, removed ambiguity)
  - "Python style"
- support for async iterators (possibly need a better name)
  - `await for` loops (not in comprehensions, too complex)
  - fits in rest of language
- all typesets have **no** null value
  - compiler should error if a null is used to satisfy a typeset
  - interfaces and `any` are considered typesets (reminder)
  - this includes anywhere where null is implicit (eg. null initialization)
- classifier values (cvals) should be i32 not i16
  - alignment of all data structures where they are used means the
  memory that would be saved is padded away anyways
