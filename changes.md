# Changes

- make errors include positions (TokenError, ASTError, etc.)
- `closed` type definitions
- remove `->` operator, just use `.` for everything (inc. methods), update `?->` to `?.` accordingly
- overload `?.` for interfaces
- split up loops into two categories: `for` and `loop`
  - `loop` is for infinite and conditional loops `loop (expr) { ... }`
    and `loop { }` for infinite loops
  - `for` is for iterative for loops (c-style, iterators)
- change expression local syntax to `x := value in expr`
- remove `then`
- remove necessity of `new` keyword (can keep `make` syntax tho)
- remove constructors (can be implemented as `NewType()` methods if really necessary)
- make init lists main way to initialize structured types
  - don't have to provide values for everything
- constancy only applies to references and variables (mutable, named values)
  - for variable declarators:
    - `const x ...`
    - constancy will be applied as an optimization after semantic checking
      where possible
  - same syntax for structs and function arguments
  - for references:
    - `&const x` (create a const reference to x)
    - `const dyn* x` (constant dynamic reference)
    - `const* x` (const stack reference)
    - `const vol* x` (constant volatile reference)
  - reference constancy is viral
    - `let x = &const y;` (x is now a const reference)
    - x can still be mutated, the reference cannot be
  - value constancy is not
    - `const x = 10; let y = x;` (y is not constant)
  - casting rules: mutable -> constant, constant -/> mutable
  - methods can be constant (explicitly)
- cannot take a non-const reference to a constant value
- remove `static`
- value categories
  - lvalue (well-defined, mutable value, able to take both kinds of references to it)
  - cvalue (well-defined, immutable value, only able to take a const reference to it, value constancy)
  - rvalue (undefined, immutable value, unable to take any kind of reference to it)
- partial function calling (replacement for old partial function syntax)
  - `f(_, 23, _)` creates a function from f that accepts the two arguments left blank
  - can allow for "currying" (not actually but...)
  - more clear than implicit currying/argument omission (re. Haskell)
- memory model **MORE CONSIDERATION NECESSARY**
  - most memory management done in terms of references
  - a reference is like a pointer except you can't mutate the pointer directly
  - two kinds of references: regular and const references
  - `make` returns a reference
    - if it is a single item, it returns a reference to that item
    - if it is a block, returns a reference to an array
    - can be resized via `make &arr to new_size`
  - references can never be explicitly dereferenced and have virtually identical semantics
  to their non-reference counterparts
  - created with syntax `&value` or `&const value`
  - type label: `&type` or `const& type`
  - dereferences are implicit (eg. storing a non-reference variable or passing as a non-reference argument)
  - compiler-determined lifetimes, user-defined ownership status
  - sometimes user will need to specify (ie. nonlocal lifetimes)
  - protective semantics
    - lifetime congruence (eg. can't return a stack reference, can't make a stack reference global)
    - `own` is a type specifier that determines what type of reference we are dealing with
    - ownership status must match exactly
    - notably, it maintains on rvalues across equals and drops for all other value categories
    - operator usage: `:>`, `delete`, and resize on mutable owned references, `=` on unowned references
  - remove nullable dereference (keep nullable get item)
  - make all/some trailers nullable **(?)**
  - usages of pointers
    - considered unsafe (perhaps only allow direct use in an `unsafe` block **(?)**)
    - no real protection
    - can be cast to and from references
    - only recommended for use where absolutely necessary
  - some form of null coalescion **(?)**
- move operator overloads outside of interfaces
  - allows for more efficient overloads (defined in terms of functions, makes more sense)
  - operators can be "left-handed" or "right-handed"
  - logically, an operator doesn't have a "primary operand" (when we see `2 + 3`, we don't think `2.add(3)`)
- builtin support for vectorization
  - vector constructor: `<value : const_len>` or `<{elems...}>`
  - vector data type: `<size>type` (only valid on integral, floating point or pointer types)
  - vector generics: `<T, in N>` (N is a size parameter to a vector data type)
  - all basic arithmetic operations are valid on vectors (scalar and vector mult)
  - additional intrinsics and utilities (eg. `__vec_sum(v)` and `__shuffle_vec(v1, v2, mask)`)
  - `#vec_unroll` annotation to cause vector functions to be optimized (as much as possible)
  - extended (later) as part of math library (intended for general purpose use, also used in matrices and complex numbers)
  - vector array initializers should be compiled as `shufflevector` if possible
  - VECTORS ARE ITERABLE
- intrinsic implementation
  - prevent intrinsics from being converted to first class functions
  - allow for generic intrinsics
  - `#intrinsic` annotation (implementation)
- inline method calls (as much as possible - may only be possible in type interfaces)
- remove group overloading (it just seems awkward - leads to duplication and ambiguity)
- allow pass by reference arguments (for ease of use of collections)
  - avoids us having to implement reference semantics on collections for usability
  - only used function arguments so not ambiguous
  - trims down on unnecessary pointers and dereferences (use of pointers where pointers make no sense)
  - makes code more readable
- allow tuple unpacking in inline vars `(x, y) := fn() in expr`
